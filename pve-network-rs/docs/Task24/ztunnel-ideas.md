# Идеи ztunnel для Proxmox-Stack (Rust + eBPF + aya)

## 1. Общий взгляд
- **Цель**: заменить пер-подовые sidecar’ы единственным узловым агентом (нечто вроде ztunnel), написанным на Rust.
- **Функции агента**: перехват и шифрование L4-трафика, применение политик, сбор метрик.
- **Контроль**: все решения (кто, куда, с какими правилами) остаются за control-plane (`net-api`/`AppContext`). Агент исполняет только dataplane.

## 2. Архитектура агента
- **Процесс/удалённый сервис**: один агент на узел, запускается как systemd unit/pod.
- **Интерфейс**: gRPC/REST/websocket для получения команд от control-plane.
- **Интеграция с EventBus**: подписка на `SystemEvent::NetworkApplied`, `SystemEvent::StorageVlanCreated` и др.
- **Конфигурация безопасности**:
  - загрузка сертификатов для mTLS;
  - ограниченные права (CAP_NET_ADMIN для eBPF/iptables, минимальные FS-доступы).

## 3. eBPF и aya
- Используем `aya` для загрузки/управления BPF-программами.
- Основной pipeline:
  1. `aya` загружает BPF-программу (socket filter/xdp/tc) в ядро;
  2. BPF на уровне ядра перехватывает пакеты и направляет их в userspace агент;
  3. Агент шифрует/логирует/применяет политики и отправляет пакеты дальше (через raw сокеты).
- Пример кода загрузки eBPF (псевдо):
  ```rust
  let mut bpf = aya::Bpf::load_file("/opt/proxmox/net_agent.bpf.o")?;
  let mut prog: SocketFilter = bpf.program_mut("net_agent_filter")?.try_into()?;
  prog.load()?;
  prog.attach("eth0", SocketFilterMode::SkSkb)?;
  ```
- BPF карты (`HashMap`, `PerfArray`) используются для передачи метаданных/метрик между ядром и userspace.

## 4. Основные функции
### 4.1 Перехват и шифрование
- При поступлении пакета BPF определяет направление → userspace агент оборачивает его в mTLS сессии.
- Идентичность/сертификаты выдаёт control-plane (`net-api` через event + secret storage).

### 4.2 Политики (AuthZ)
- Агент хранит локальный кэш правил: кто может общаться с кем (по VM ID, контейнеру, зоне, VLAN).
- Правила приходят из `AppContext` (через REST/EventBus). BPF использует фильтр для первичной проверки, агент — для детальной.

### 4.3 Управление iptables/nftables
- Для fallback/legacy сценариев агент может вносить правила в `iptables`/`nft` используя
  ```rust
  let mut ipt = iptables::new(false)?;
  ipt.append("filter", "FORWARD", "..." );
  ```
- Но акцент делаем на eBPF (aya) как основную механизм.

### 4.4 Метрики и события
- Агент публикует `SystemEvent::NetworkApplied` с расширенными данными (байты, latency).
- Использует PerfEvent/BPF карты для доставки статистики пользователям (CLI/API).

## 5. Интеграция с AppContext
- Новый crate (условно `net-agent`) регистрируется в `AppContext::bootstrap`.
- Триггеры:
  - `NetworkApplied` → пересоздать BPF/iptables правила;
  - `StorageVlanCreated` → обновить VLAN фильтры;
  - `MigrationPhaseChanged` → переключить режим (например, особые правила на время миграции).
- Обновления конфигов: agent предоставляет API, `AppContext` отправляет diff (JSON/Proto) при изменении сетевых политик.

## 6. План разработки
1. Определить формат команд/политик (JSON Schema или Protobuf).
2. Собрать минимальный `net-agent`:
   - eBPF фильтр (aya) для перехвата L2/L3;
   - userspace демон для применения TLS/логики;
   - интеграция с EventBus (подписка/публикация).
3. Связать с `AppContext`: добавить новый компонент, который синхронизирует политику и метрики.
4. Расширять функциональность:
   - QoS, rate limiting;
   - DPI/Layer7; 
   - интеграция с storage/SDN сценариями.
5. Подготовить документацию + тесты (unit для BPF, e2e для прокси).

## 7. Инфраструктурные требования
- Узлу нужны права на загрузку BPF (CAP_BPF/CAP_SYS_ADMIN) и управление сетевыми интерфейсами.
- Для TLS — секреты (сертификаты) в защищённом хранилище; предпочтительно — динамическая выдача (как в Istio sds).
- Логи/метрики собираются в общий мониторинг (Prometheus/OpenTelemetry).

## 8. Относительные плюсы/риски
- **Плюсы**: меньше overhead, единый контроль сетевых политик, возможность глубокого анализа трафика, шифрование из коробки.
- **Минусы**: сложность разработки (нужны знания eBPF), требования к безопасности (доступ к ядру), необходимость координации control plane.

## 9. Следующие шаги
- Подготовить `net-agent` прототип (Rust + aya).
- Определить API/протокол обмена с `net-api`.
- Написать spec (Task25) с подробной архитектурой/критериями приёмки.
- Наметить миграцию существующих сетевых сценариев Proxmox на новый агент.
